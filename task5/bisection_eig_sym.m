function [D] = bisection_eig_sym(A,a,b,tol)
%BISECTION_EIG_SYM - вычисление собственных чисел симметричной трёхдиагональной
% матрицы A в диапазоне от a до b  с точностью tol  
%   

if (a>b) % a должно быть меньше b
    c = a; 
    a = b; 
    b = c; 
end

Na = neg_count_sym(A,a); % количество собственных значений меньше a
Nb = neg_count_sym(A,b); % количество собственных значений меньше b
D = []; % переменная для сбора найденных собственных значений
if(Na == Nb) % в заданном интервале ни одного собственного числа нет
    return;
else
    Worklist1 = zeros(abs(Nb-Na),4); % список интевалов (abs(Nb-Na) - максимально необходимое число интервалов, заранее выделяем память)
    Worklist2 = zeros(abs(Nb-Na),4); % новый список инервалов
    lenW1 = 1; % число интервалов
    Worklist1(1,:) = [a,b,Na,Nb];  % на начало алгоритма есть один интевал
    lenW2 = 0; % число новых интервалов
end

while (lenW1>0) % итерируем пока список интервалов не пуст
    for(ii = 1:lenW1) % проходим по всем интервалам текущего набора 
        if(Worklist1(ii,2)-Worklist1(ii,1)<tol) % если длина текущего интервала меньше заданной точности,то 
            nD = Worklist1(ii,4)-Worklist1(ii,3); % вычислить количество приходящихся на интрвал собсвенных чисел
            d = (Worklist1(ii,2)+Worklist1(ii,1))/2;% опредеденить середину текщего интрвала как среднее значение всех собственных чисел интервала
            D = [D,ones(1,nD).*d]; % поместить в D нужное количество элементов соответсвующих собственным значениям текущего интевала
        else % иначе: одновляем список интервалов
            mid = (Worklist1(ii,2)+Worklist1(ii,1))/2; % опредлеяем середину текущего интервала
            Nmid = neg_count_sym(A,mid); % надохим количество собственных значений меньших чем середина текущего интевала
            if(Nmid>Worklist1(ii,3)) % если число собственных значений больше чем число собственных значений меньших чем левый край, то добавляем в новый интервал в новый сисок интервалов
                lenW2 = lenW2 + 1; % увеличиваем длину списка новых интрвалов
                Worklist2(lenW2,:) = [Worklist1(ii,1),mid,Worklist1(ii,3),Nmid]; % добавляем запись в список новых интервалов - новый интервал - левая половина текущего интрвала
            end
            if(Worklist1(ii,4)>Nmid) % проверяем, есть - ли собственные значения в правой половине текущего интервала, если есть,то:
                lenW2 = lenW2 + 1; % увеличиваем длину списка новых интервалов
                Worklist2(lenW2,:) = [mid,Worklist1(ii,2),Nmid,Worklist1(ii,4)]; % дабавляем правую половинутекущего интервада в новый список интервалов
            end
        end
    end
    Worklist1 = Worklist2; % новый список интервлов помещаем на место старого
    lenW1 = lenW2; % корректно сохраняем длину списка
    lenW2 = 0; % новый список снова пуст
end
% при выходе из данного цилка массив собственных значений D будет заполнен


end

