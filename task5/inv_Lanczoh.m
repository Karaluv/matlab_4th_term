function [T,Q] = inv_Lanczoh(A,sg,b,k)
%INV_LANCZOH  Приведение к  трёхдиагональной (частичной) форме алгоритмом Ланцоша 
%   A - матрица
%   sg - значение вблизи которого нужно найти сосбтвенные числа матрицы A
%   b - входной вектор
%   k - размер выходной трёхдиагональной матрицы T

%   T - трёхжиагональная матрица размера k x k
%   Q - матрица отображения на k-мерное крыловское подстространство 


szA = size(A); % оперделяем размер матрицы

q1 = b./norm(b); % нормируем входящий вектор
q0 = 0.*q1; % вектор "предыдущей" итерации,на начале он равен нулю
bet0 = 0; 

alf = zeros(1,k);% это массив для  хранения элементов главной диагонали
bet = zeros(1,k);% массив для элементов нижней (верхней) диагонали
Q = zeros(szA(1),k); % матрица отображения A в трехдиагональный вид T = Q'*A*Q, Q'*Q = I

% смешаем спектр матрицы
if(issparse (A))
    A = A - sg.*speye(szA(1),szA(1));
else
    A = A - sg.*eye(szA(1),szA(1));
end


for ii = 1:k % итерируем 
    z = CCGSolver(A,q1,1e-10); % Решение СЛАУ - эквивалентно A^-1*q1 - наименьшие по модую собственные числа A1 играют основную роль 
    alf(ii) = q1'*z; % определение диагонального элмента
    z = z - alf(ii).*q1-bet0.*q0; % ортогонализируем вектор z к прердыдушему вектору q1
    bet(ii) = norm(z);% значение поддиагонального элемента
    bet0 = bet(ii);
    if (bet0 == 0 )
        break;
    end
    Q(:,ii) = q1;% сохраняем новый вектор
    q0 = q1;
    q1 = z./bet(ii);
    q1 = ortgnlz(Q,q1,ii); % ортогонализуем вектор по отношению к ранее найденному базису
end

% Формирование трёхдиагональной матрицы как разрежённой матрицы
v  = [alf,bet(1:end-1),bet(1:end-1)]; % массив ненулевых элементов  
ii = [1:k,1:k-1,2:k]; % массив номеров строк
jj = [1:k,2:k,1:k-1]; % массив номеров столбцов

T = sparse(ii,jj,v); % формируем разреженную матрицу

end
